#!/usr/bin/env python
'''
*****************************COPYRIGHT******************************
 (C) Crown copyright 2021 Met Office. All rights reserved.

 Use, duplication or disclosure of this code is subject to the restrictions
 as set forth in the licence. If no licence has been raised with this copy
 of the code, the use, duplication or disclosure of it is strictly
 prohibited. Permission to do so must first be obtained in writing from the
 Met Office Information Asset Owner at the following address:

 Met Office, FitzRoy Road, Exeter, Devon, EX1 3PB, United Kingdom
*****************************COPYRIGHT******************************
NAME
    link_drivers

DESCRIPTION
    Top level control to coordinate either single or multiple model drivers
    to run a given configuration
'''

#The from __future__ imports ensure compatibility between python2.7 and 3.x
from __future__ import absolute_import
import importlib
import sys
import os
import argparse
import error
import common
import create_namcouple
import dr_env_lib.common_def
import dr_env_lib.env_lib

#A tuple for for the earlist version of python required to run the drivers
REQUIRED_VERSION = (3, 6)

def _check_drivers(models):
    '''
    Takes in our space separated list of models, and ensure that a driver is
    present for the module
    '''
    sys.stdout.write('MODELS %s\n' % models)

    models = models.split(' ')
    for model in models:
        drivername = '%s_driver.py' % model
        if not os.path.isfile(drivername):
            # check to see if this is a controller rather than a driver
            controllername = '%s_controller.py' % model
            if os.path.isfile(controllername):
                models.remove(model)
            else:
                sys.stderr.write('[FAIL] Can not find driver file for model %s.'
                                 ' The driver file should be named %s\n' %
                                 (model, drivername))
                sys.exit(error.MISSING_DRIVER_ERROR)
    # If the MCT driver is present this should be last in the list
    models.sort(key='mct'.__eq__)
    return models

def _run_drivers(common_env, mode, run_info):
    '''
    Run the driver modules, and return an instance of LoadEnvar
    containing environment variables for that module, and a string containing
    a launcher command. This somewhat convoluted method ensures this
    module doesn't have to be modified when adding a new model. The mode is
    either run_driver to run the model, or finalize to run the finalization
    routines.
    '''
    if mode not in ('run_driver', 'finalize', 'failure'):
        sys.stderr.write('[FAIL] driver only has run_driver, finalize, or'
                         ' failure modes\n')
        sys.exit(error.MISSING_EVAR_ERROR)
    models = _check_drivers(common_env['models'])
    if mode == 'failure':
        # Only UM, NEMO and CICE drivers have failure mode
        failure_mode_models = []
        for model in models:
            if model in ('um', 'nemo', 'cice'):
                failure_mode_models.append(model)
        models = failure_mode_models
    envinsts = {'common': common_env}
    launchcmds = []
    coupling_list = []
    for model in models:
        # namespace dictionary for exec function
        driver_name = '%s_driver' % model
        driver_mod = importlib.import_module(driver_name)
        if model != 'mct':
            model_envars, model_launch_cmd, run_info, model_snd_list \
                = driver_mod.run_driver(envinsts['common'], mode, run_info)
        else:
            model_envars, model_launch_cmd, run_info, model_snd_list \
                = driver_mod.run_driver(envinsts, mode, run_info)
        envinsts[model] = model_envars
        launchcmds.append(model_launch_cmd)
        if model_snd_list:
            if coupling_list:
                coupling_list.extend(model_snd_list)
            else:
                coupling_list = model_snd_list
        del driver_mod
    return envinsts, launchcmds, run_info, coupling_list


def _setup_common():
    '''
    Load environment variables common to all models
    '''
    common_env = dr_env_lib.env_lib.LoadEnvar()
    common_env = dr_env_lib.env_lib.load_envar_from_definition(
        common_env, dr_env_lib.common_def.COMMON_ENVIRONMENT_VARS_INIT_FIN)

    # make any required correctons to the CONTINUE and CONTINUE_FROM_FAIL
    # variables
    common_env = dr_env_lib.env_lib.set_continue_cont_from_fail(
        common_env)

    return common_env

def _export_cmd_str_XC40(launchcmds, common_env):
    '''
    Create an aprun launch command for the coupled configuration on the
    XC40
    '''
    cmd = '%s ' % common_env['ROSE_LAUNCHER']
    for launchcmd in launchcmds:
        if launchcmd != '':
            cmd += launchcmd+' : '
    sys.stdout.write('[LINK_DRIVERS] attemting to run with command: %s\n'
                     % cmd[:-3])
    return cmd[:-3]






if __name__ == '__main__':
    # Owing to the limitations of aprun and passing information between the
    # shell and the python drivers, prepare two command files, one containing
    # an aprun command to execute, the other containing a command allowing
    # environment variables to be exported

    try:
        assert sys.version_info >= REQUIRED_VERSION
        sys.stdout.write('Using python version %i.%i\n' %
                         (sys.version_info[0], sys.version_info[1]))
    except AssertionError:
        sys.stderr.write('Python version must be %i.%i or later. Currently'
                         ' using %i.%i\n' % (REQUIRED_VERSION[0],
                                             REQUIRED_VERSION[1],
                                             sys.version_info[0],
                                             sys.version_info[1]))
        sys.exit(error.VERSION_ERROR)

    parser = argparse.ArgumentParser()
    parser.add_argument("--run", help="run the coupled model",
                        action="store_true")
    parser.add_argument("--finalize", help="run the model finalize routines",
                        action="store_true")
    parser.add_argument("--failure", help="run the mode in failure mode",
                        action="store_true")
    args = parser.parse_args()
    if args.run and args.finalize:
        sys.stderr.write('[FAIL] the run and finalize options are mutually'
                         ' exclusive')
        sys.exit(error.INVALID_DRIVER_ARG_ERROR)
    if args.run:
        mode = 'run_driver'
        # Setup the environment variables required to all drivers
        common_env = _setup_common()

        # Determine if namcouple should be created
        if common_env['HYBRID_COMPONENT'] == 'none':
            sys.stdout.write('[INFO] namcouple should exist in suite.\n')
            run_info = {'l_namcouple': True}
        else:
            sys.stdout.write('[INFO] namcouple will be created.\n')
            run_info = {'l_namcouple': False}
            # Creating a namcouple on the fly will only work if the f90nml
            # module is available
            try:
                import f90nml
            except ImportError:
                sys.stderr.write('[FAIL] The python f90nml module is '
                                 'required to create the namcouple file '
                                 'on the fly, and it is unavailable in '
                                 'this setup.\n')
                sys.exit(error.F90NML_UNAVAILABLE)

        # Create two lists by looping through all the required driver files:
        #    1. envinsts is a list of LoadEnvar() instances, each
        #      instance containing environment variables for a given driver
        #    2. launchcmds is a list of strings, containing options for each
        #      model to be passed to the parallel launcher on the system.
        envinsts, launchcmds, run_info, coupling_list \
            = _run_drivers(common_env, mode, run_info)

        # Create the namcouple file
        if not run_info['l_namcouple']:
            create_namcouple.write_namcouple(
                common_env,run_info, coupling_list)

        # Create a string containing the export command and a list of
        # environment variable definitions that can be run by the shell
        envar_str = dr_env_lib.env_lib.string_for_export(envinsts)

        # Create the aprun command
        cmd_str = _export_cmd_str_XC40(launchcmds, common_env)

        # Write the export commands for common and model specific environment
        # variables (envar_str) into the file driver_envar
        envar_file = common.open_text_file('driver_envar', 'w')
        envar_file.write(envar_str)
        envar_file.close()

        # Write the model launch commands (cmd_str) into file driver_cmd
        cmd_file = common.open_text_file('driver_cmd', 'w')
        cmd_file.write(cmd_str)
        cmd_file.close()
    elif args.finalize:
        mode = 'finalize'
        common_env = _setup_common()
        run_info = {}
        _, _, _, _ = _run_drivers(common_env, mode, run_info)
    elif args.failure:
        mode = 'failure'
        common_env = _setup_common()
        run_info = {}
        _, _, _, _ = _run_drivers(common_env, mode, run_info)
